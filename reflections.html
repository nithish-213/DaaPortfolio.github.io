<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="Portfolio of J Nithish, a passionate web developer skilled in web development, C++, Python, JavaScript, and algorithms."
    />
    <meta
      name="keywords"
      content="J Nithish, portfolio, web developer, DAA project, KLE Technological University"
    />
    <meta name="author" content="J Nithish" />
    <meta
      property="og:title"
      content="J Nithish - Web Developer Portfolio"
    />
    <meta
      property="og:description"
      content="Explore my skills, projects, and contact details."
    />
    <title>Nithish - Reflections</title>

    <!-- Font Awesome icons -->
    <script
      src="https://kit.fontawesome.com/a9cdbedf57.js"
      crossorigin="anonymous"
    ></script>

    <!-- Styling CSS -->
    <link rel="stylesheet" id="themeStylesheet" href="./style.css" />

    <!-- External Font -->
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap"
      rel="stylesheet"
    />
  </head>

  <body>
    <header>
      <div>
        <h2 class="hero-section__desc"><span>Course Project</span></h2>
      </div>
    </header>

    <main>
   <!-- DAA Lab Reflections -->
      <section class="about-section" id="about">
        <div class="about-content">
          <h2 class="title">DAA Lab Reflections</h2>

          <!-- Key Concepts Learned -->
          <h3>Key Concepts Learned</h3>
          <ul>
            <li>Time Complexity Analysis</li>
            <li>Binary Search Tree</li>
            <li>DFS and BFS</li>
            <li>Heap</li>
            <li>Sorting</li>
            <li>Pattern Searching</li>
            <li>Graph Algorithms</li>
          </ul>

          <!-- Challenges -->
          <h3>1. Challenges in Learning/Understanding the Above Concepts</h3>
          <ul>
            <li>
              <b>Time Complexity Analysis:</b> Requires a deep understanding of
              mathematical notations like Big-O, Theta, and Omega.
            </li>
            <li>
              <b>Binary Search Tree:</b> Difficulty in understanding rotations
              during insertion and deletion operations.
            </li>
            <li>
              <b>DFS and BFS:</b> Requires grasping recursion for DFS and
              queue-based implementation for BFS.
            </li>
            <li>
              <b>Heap:</b> Understanding the heapify process and its application
              in priority queues.
            </li>
            <li>
              <b>Sorting:</b> Choosing between algorithms like QuickSort,
              MergeSort, or HeapSort for optimal performance.
            </li>
            <li>
              <b>Pattern Searching:</b> Challenges in implementing algorithms
              like KMP due to preprocessing requirements.
            </li>
            <li>
              <b>Graph Algorithms:</b> Modeling real-world problems and
              understanding shortest path or MST algorithms.
            </li>
          </ul>

          <h3>2. Challenges in Correlating with Real-World Applications</h3>
          <ul>
            <li>
              <b>Time Complexity Analysis:</b> Applying theoretical efficiency
              to large-scale systems like web servers.
            </li>
            <li>
              <b>Binary Search Tree:</b> Optimizing database search operations
              using balanced trees like AVL or Red-Black Trees.
            </li>
            <li>
              <b>DFS and BFS:</b> Using these in navigation systems or solving
              puzzles like mazes.
            </li>
            <li>
              <b>Heap:</b> Applications in job scheduling or real-time priority
              management.
            </li>
            <li>
              <b>Sorting:</b> Efficiently handling data in e-commerce platforms
              or search engines.
            </li>
            <li>
              <b>Pattern Searching:</b> Real-world applications in text editors
              or DNA sequence analysis.
            </li>
            <li>
              <b>Graph Algorithms:</b> Applications in social networks,
              logistics, and communication networks.
            </li>
          </ul>
          
          <h3>3. Determining the Most Efficient Approach/Design Techniques</h3>
          <ul>
            <li>
              <b>Time Complexity Analysis:</b> Start with brute force and
              optimize incrementally by analyzing time complexity.
            </li>
            <li>
              <b>Binary Search Tree:</b> Use AVL or Red-Black Trees for balanced
              data storage and retrieval.
              <pre>
                void insert(Node*& root, int value) {
                if (root == nullptr) {
                root = new Node(value);
                return;
                }
                if (value < root->data) {
                  insert(root->left, value);
                  }
                  else {
                  insert(root->right, value);
                  }
                  root = balance(root);
                  }
              </pre>
            </li>
            <li>
              <b>DFS and BFS:</b> Choose DFS for pathfinding problems and BFS
              for shortest path in unweighted graphs.
              <pre>
                void BFS(Graph& g, int start) {
                queue q;
                vector visited(g.size(), false);
                q.push(start);
                visited[start] = true;
                while (!q.empty()) {
                int node = q.front();
                q.pop();
                cout << node << " ";
                  for (int neighbor : g[node]) {
                  if (!visited[neighbor]) {
                  q.push(neighbor);
                  visited[neighbor] = true;
                  }
                  }
                  }
                  }
                </pre>
            </li>
                  <li>
                    <b>Heap:</b> Use heaps for implementing efficient priority queues.
                    <pre>
                      void heapify(vector& heap, int n, int i) {
                      int largest = i;
                      int left = 2 * i + 1;
                      int right = 2 * i + 2;
                      if (left < n && heap[left] > heap[largest])
                        largest = left;
                        if (right < n && heap[right] > heap[largest])
                          largest = right;
                          if (largest != i) {
                          swap(heap[i], heap[largest]);
                          heapify(heap, n, largest);
                          }
                          }
                        </pre>
                  </li>
                          <li>
                            <b>Sorting:</b> Use MergeSort for stability, QuickSort for in-place sorting, and HeapSort for space efficiency.
                            <pre>
                              void quickSort(vector& arr, int low, int high) {
                              if (low < high) {
                              int pi = partition(arr, low, high);
                              quickSort(arr, low, pi - 1);
                              quickSort(arr, pi + 1, high);
                              }
                              }
                            </pre>
                          </li>
                                <li>
                                  <b>Pattern Searching:</b> Apply KMP or Rabin-Karp for pattern matching in large datasets efficiently.
                                  <pre>
                                    void computeLPSArray(string pattern, int M, int* lps) {
                                    int len = 0;
                                    lps[0] = 0;
                                    int i = 1;
                                    while (i < M) {
                                    if (pattern[i] == pattern[len]) {
                                    len++;
                                    lps[i] = len;
                                    i++;
                                    }
                                    else {
                                    if (len != 0) {
                                    len = lps[len - 1];
                                    }
                                    else {
                                    lps[i] = 0;
                                    i++;
                                    }
                                    }
                                    }
                                    }
                                  </pre>
                                </li>
                                      <li>
                                        <b>Graph Algorithms:</b> Use Dijkstra for shortest paths, Prim or Kruskal for MST, and Bellman-Ford for graphs with negative weights.
                                        <pre>
                                          void dijkstra(vector>>& graph, int src) {
                                          priority_queue, vector>, greater>> pq;
                                          vector dist(graph.size(), INT_MAX);
                                          pq.push({0, src});
                                          dist[src] = 0;
                                          while (!pq.empty()) {
                                          int u = pq.top().second;
                                          pq.pop();
                                          for (auto& neighbor : graph[u]) {
                                          int v = neighbor.first;
                                          int weight = neighbor.second;
                                          if (dist[u] + weight < dist[v]) {
                                          dist[v] = dist[u] + weight;
                                          pq.push({dist[v], v});
                                          }
                                          }
                                          }
                                          }
                                        </pre>
                                      </li>
         </ul>
        </div>

        <div class="about-content">
          <h2 class="title">DAA Theory Reflections</h2>
          <ol>
                <li>
                    What are the kinds of problems we see in nature? (iteration, recursion, backtracking)
                    <p class="ans">
                        In nature, we can see problems being solved in ways similar to computational techniques like iteration, recursion, and backtracking. 
                        For example, iteration shows up in things like the repeating cycles of seasons or the rise and fall of predator-prey populations. 
                        Recursion is easy to spot in patterns like snowflakes, the way trees branch out, or how rivers split into smaller streams—all of them repeating the same shapes on different scales. 
                        Backtracking happens when animals, like ants or rats, try one path to find food, hit a dead end, and go back to try another. 
                        Nature uses these methods to adapt, solve problems, and make things work efficiently.
                    </p>
                </li>
                <li>
                    What is space and time efficiency? Why are they important? Explain the different classes of problems and orders of growth.
                    <p class="ans">
                        Space and time efficiency refer to how much memory it uses as the input size grows and how fast an algorithm runs. 
                        Time efficiency ensures the program runs quickly, while space efficiency focuses on saving memory, which is especially important in resource-limited environments. 
                        The different class of problem can be represented in form of graph as follows:
                        <br>
                            O(1): constant order of growth 
                        <br>
                            O(n): linear order of growth 
                        <br>
                            O(log n): logarithmic order of growth 
                        <br>
                            O(nlogn): Runtime increases more than linear but less than quadratic with input size.
                        <br>
                            O(n2): Runtime increases quadratically.
                        <br>
                            O(n3): Runtime increases cubic.
                        <br>
                            O(2^n): The runtime grows exponentially.
                        <br>
                            O(n!): The runtime grows extremely fast.
                    </p>
                </li>
                <li>
                    Take away from different design principles from chapter 2?
                    <p class="ans">
                        The key takeaway from the design principles is how simple strategies can make complex problems more manageable and algorithms more efficient. 
                        By using principles like decomposition, pattern recognition, and abstraction, we break down tasks into smaller parts. 
                        Techniques like pruning (in N-queens) and lazy propagation (in segment trees) optimize resource use, eliminating unnecessary steps or delaying updates until needed. 
                        Hierarchical order (in BST) and level order traversal (in BFS) help us process data effectively. 
                        Pre-computing results, like in lookup tables, simplifies repeated operations. 
                        Using parental dominance in heaps and bit manipulation in Fenwick trees speeds up calculations. 
                        Finally, DFS and BFS teach us to navigate graphs with careful traversal. 
                        All these principles combine to create more efficient algorithms.
                    </p>
                </li>
                <li>
                    The hierarchical data and how different tree data structures solve and optimize over problem scenarios (tree, bst, avl, 2-3, red-black, heap, trie)
                    <p class="ans">
                        Tree data structures are essential for organizing hierarchical data and optimizing operations like searching, sorting, and indexing. 
                        A general tree provides flexibility for generic hierarchies but lacks efficiency. 
                        Binary trees are foundational but can become inefficient if unbalanced. 
                        Self-balancing trees like AVL and Red-Black trees ensure \(O(\log n)\) operations, with AVL trees being more strictly balanced and Red-Black trees easier to maintain during frequent updates. 
                        Heaps are ideal for priority-based tasks (e.g., scheduling), while Tries excel in prefix searches and string operations, such as autocompletion. 
                        Multiway trees like 2-3 trees offer consistent balancing, making them perfect for databases and file systems. 
                        Each structure is tailored to specific scenarios, balancing trade-offs between speed, complexity, and memory usage.
                    </p>
                </li>
                <li>
                    The need for array query algorithms and their implications. Their applications and principles need to be discussed.
                    <p class="ans">
                        Array query algorithms are essential for quickly answering questions about data, such as range sums, maximum values, or patterns, especially in large datasets. 
                        They balance preprocessing, memory usage, and query speed to handle real-time applications like databases, gaming, analytics, and machine learning. 
                        Techniques like prefix sums, Fenwick trees, segment trees, and sliding windows are widely used to optimize operations, ensuring fast responses and efficient updates. 
                        These algorithms are foundational for modern systems where scalability and performance are critical.
                    </p>
                </li>
                <li>
                    Differentiate between tree and graphs and their traversals. The applications of each.
                    <p class="ans">
                        Tree <br>
                        -A connected, acyclic graph with n nodes and n-1 edges. <br>
                        -always has a root node. <br>
                        -always connected. <br>
                        -no cycles. <br>
                        
                       <br> Graphs <br>
                        -Collection of vertices connected by edges, cyclic and even disconnected. <br>
                        -no specific root unless mentioned. <br>
                        -can be connected or disconnected. <br>
                        -have cycles. <br>
                        
                        <br> Tree traversals <br>
                        1. Pre order: Root,Left,Right <br>
                        2. In order: Left, Root, Right <br>
                        3. Post order: Left, Right, Root <br>
                        <br> Eg: heap, BST for search, insert, delete <br>
                        
                        <br> Graph Traversals <br>
                       <br> DFS: traverse as deep as possible before backtracking. <br>
                         Eg: Road maps, Invitation problem. <br>
                        
                       <br> BFS: visit all neighbour nodes before moving. <br>
                        Eg: Networks (social networks)
                    </p>
                </li>
                <li>
                    Deliberate on sorting and searching algorithms, the technique behind each and how they connect to the real world.
                    <p class="ans">
                        Sorting and searching algorithms are vital for organizing and retrieving data efficiently. 
                        Sorting arranges data in a specific order, using techniques like quicksort for speed or counting sort for specific cases, while searching locates items, with binary search excelling on sorted datasets. 
                        These algorithms power real-world applications like search engines, e-commerce filters, and route planning, ensuring quick and reliable results. 
                        Together, they enable efficient data handling, forming the backbone of modern systems like databases, AI, and analytics.
                    </p>
                </li>
                <li>
                    Discuss the importance of graph algorithms with respect to spanning trees and shortest paths.
                    <p class="ans">
                        Graph algorithms, especially for spanning trees and shortest paths, are essential for optimizing real-world systems like networks, navigation, and logistics. 
                        Spanning tree algorithms help efficiently connect all nodes with minimal cost, making them crucial for network design and broadcasting. 
                        Shortest path algorithms, like Dijkstra’s, are used to find the fastest or most cost-effective route, impacting applications like GPS navigation, data routing, and supply chain management. 
                        Together, these algorithms ensure efficient and cost-effective connectivity in fields like telecommunications, transportation, and resource management.
                    </p>
                </li>
                <li>
                    Discuss the different studied algorithm design techniques.
                    <p class="ans">
                        In class, we explored several design techniques, starting with backtracking, where we solved problems like the n-queens and subset generation by considering all possibilities and eliminating unnecessary ones. 
                        We also learned about transform and conquer with AVL trees, heaps, and 2-3 trees. 
                        Moving on to decrease and conquer, we studied graph traversals like BFS and DFS. 
                        We covered divide and conquer through sorting algorithms and string matching techniques, including the Boyer-Moore algorithm, which uses space and time trade-offs. 
                        Finally, we explored greedy algorithms, such as Prim’s, Kruskal’s, and Dijkstra’s, to find the shortest path in weighted graphs.
                    </p>
                </li>
            </ol>
        </div>

      </section>
      </main>
    <!-- Footer -->
    <footer>
      <p>
        Copyright &copy; <span id="year"></span>
        <a href="https://github.com/nithish_213" target="_blank" rel="noopener"
          >Nithish</a
        >
        - All Rights Reserved.
      </p>
    </footer>

    <!-- JavaScript -->
    <script src="./script.js"></script>
  </body>
</html>
